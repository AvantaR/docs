---
title: Self-relations
metaDescription: How to define and work with self-relations in Prisma.
---

<TopBlock>

A relation field can also reference its own model, in this case the relation is called a _self-relation_. Self-relations can be of any cardinality, 1-1, 1-n and m-n.

Note that self-relations always require the `@relation` attribute.

</TopBlock>

## One-to-one self-relations

The following example models a one-to-one self-relation:

```prisma
model User {
  id          Int     @default(autoincrement()) @id
  name        String?
  successorId Int?
  successor   User?   @relation("BlogOwnerHistory", fields: [successorId], references: [id])
  predecessor User?   @relation("BlogOwnerHistory")
}
```

This relation expresses the following:

- "a user can have one or zero predecessors" (for example, Sarah is Mary's predecessor as blog owner)
- "a user can have one or zero successors" (for example, Mary is Sarah's successor as blog owner)

> **Note**: One-to-one self-relations cannot be made required on both sides. One or both sides must be optional, otherwise it becomes impossible to create the first `User` record.

To create a one-to-one self-relation:

- Both sides of the relation must define a `@relation` attribute that share the same name - in this case, **BlogOwnerHistory**.
- One relation field must be a [fully annotated](#annotated-relation-fields-and-relation-scalar-fields). In this example, the `successor` field defines both the `field` and `references` arguments.
- One relation field must be backed by a foreign key. The `successor` field is backed by the `successorId` foreign key, which references a value in the `id` field.

> **Note**: One-to-one self relations require two sides even if both sides are equal in the relationship. For example, to model a 'best friends' relation, you would need to create two relation fields: `bestfriend1` and a `bestfriend2`.

Either side of the relation can be backed by a foreign key. In the following example, `successor` is backed by `successorId`:

```prisma line-number file=schema.prisma
model User {
  id          Int     @default(autoincrement()) @id
  name        String?
|  successorId Int?
|  successor   User?   @relation("BlogOwnerHistory", fields: [successorId], references: [id])
  predecessor User?   @relation("BlogOwnerHistory")
}
```

In the following example, `predecessor` is backed by `predecessorId`:

```prisma line-number file=schema.prisma
model User {
  id              Int     @default(autoincrement()) @id
  name            String?
  successor       User?   @relation("BlogOwnerHistory")
|  predecessorId   Int?
|  predecessor     User?   @relation("BlogOwnerHistory", fields: [predecessorId], references: [id])
}
```

No matter which side is backed by a foreign key, the Prisma Client surfaces both the `predecessor` and `successor` fields:

```ts line-number
  const x = await prisma.user.create({
    data: {
      name: "Bob McBob",
|      successor: {
        connect: {
          id: 2,
        },
      },
|      predecessor: {
        connect: {
          id: 4,
        },
      },
    },
  });
```

This relation is represented as follows in SQL:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    "successorId" INTEGER
);

ALTER TABLE "User" ADD CONSTRAINT fk_successor_user FOREIGN KEY ("successorId") REFERENCES "User" (id);

ALTER TABLE "User" ADD CONSTRAINT successor_unique UNIQUE ("successorId");
```

## One-to-many self relations

A one-to-many self-relation looks as follows:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  name      String?
  teacherId Int?
  teacher   User?     @relation("TeacherStudents", fields: [teacherId], references: [id])
  students  User[]    @relation("TeacherStudents")
}
```

This relation expresses the following:

- "a user has zero or one _teachers_ "
- "a user can have zero or more _students_"

Note that you can also require each user to have a teacher by making the `teacher` field [required](data-model#optional-and-mandatory-fields).

This relation is represented as follows in SQL:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    "teacherId" INTEGER
);

ALTER TABLE "User" ADD CONSTRAINT fk_teacherid_user FOREIGN KEY ("teacherId") REFERENCES "User" (id);
```

## Many-to-many self relations

A many-to-many self-relation looks as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  followedBy  User[]   @relation("UserFollows", references: [id])
  following   User[]   @relation("UserFollows", references: [id])
}
```

This relation expresses the following:

- "a user can be followed by zero or more users"
- "a user can follow zero or more users"

Note that this n-n-relation is [implicit](#implicit-many-to-many-relations). This means Prisma maintains a [relation table](#relation-tables) for it in the underlying database:

```sql
CREATE TABLE "User" (
    id integer DEFAULT nextval('"User_id_seq"'::regclass) PRIMARY KEY,
    name text
);
CREATE TABLE "_UserFollows" (
    "A" integer NOT NULL REFERENCES "User"(id) ON DELETE CASCADE ON UPDATE CASCADE,
    "B" integer NOT NULL REFERENCES "User"(id) ON DELETE CASCADE ON UPDATE CASCADE
);
```

## Defining multiple self-relations on the same model

You can also define multiple self-relations on the same model at once. Taking all relations from the previous sections as example, you could define a `User` model as follows:

```prisma
model User {
  id          Int      @id @default(autoincrement())
  name        String?
  husband     User?    @relation("MarriagePartners")
  wife        User     @relation("MarriagePartners")
  teacher     User?    @relation("TeacherStudents")
  students    User[]   @relation("TeacherStudents")
  followedBy  User[]   @relation("UserFollows")
  following   User[]   @relation("UserFollows")
}
```