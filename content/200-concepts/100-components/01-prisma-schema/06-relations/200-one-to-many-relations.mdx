---
title: One-to-many relations
metaDescription: How to define and work with one-to-many relations in Prisma.
---

<TopBlock>

One-to-many (1-n) relations refer to relations where one record on one side of the relation can be connected to zero or more records on the other side.

</TopBlock>

### One-to-one vs one-to-many relations

In relational databases, the main difference between a 1-1 and a 1-n-relation is that in a 1-1-relation the foreign key must have a `UNIQUE` constraint defined on it.

### Example

In the example below, there's one 1-n-relation between `User` and `Post`:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
}

model Post {
  id        Int   @id @default(autoincrement())
  author    User  @relation(fields: [authorId], references: [id])
  authorId  Int
}
```

> **Note** The `posts` field does not "manifest" in the underlying database schema. On the other side of the relation, the [annotated relation field](#annotated-relation-fields-and-relation-scalar-fields) `author` and its relation scalar `authorId` represent the side of the relation that stores the foreign key in the underlying database.

This 1-n-relation expresses the following:

- "a user can have zero or more posts"
- "a post must always have an author"

In SQL, this is typically modeled as follows:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "authorId" integer NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User"(id)
);
```

Since there's no `UNIQUE` constraint on the `author` column (foreign key), you can create multiple `Post` records that point to the same `User` record therefore creating a one-to-many relationship between the two tables.

You can also define this relation using [multi-field IDs](../../../reference/api-reference/prisma-schema-reference#id-1):

```prisma
model User {
  firstName String
  lastName  String
  post      Post[]

  @@id([firstName, lastName])
}

model Post {
  id               Int      @id @default(autoincrement())
  author           User     @relation(fields: [authorFirstName, authorLastName], references: [firstName, lastName])
  authorFirstName  String   // relation scalar field (used in the `@relation` attribute above)
  authorLastName   String   // relation scalar field (used in the `@relation` attribute above)
}
```

In this case, there are _two_ relation scalar fields on `Post`. This is what the models map to in SQL:

```sql
CREATE TABLE "User" (
    firstName TEXT,
    lastName TEXT,
    PRIMARY KEY ("firstName","lastName")
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "authorFirstName" TEXT NOT NULL,
    "authorLastName" TEXT NOT NULL,
    FOREIGN KEY ("authorFirstName", "authorLastName") REFERENCES "User"("firstName", "lastName")
);
```

### Required vs optional relation fields in one-to-many relations

A 1-n-relation always has two relation fields:

- a [list](data-model#type-modifiers) relation field which is _not_ annotated with `@relation`
- the [annotated relation field](#annotated-relation-fields-and-relation-scalar-fields) (including its relation scalar)

The relation fields in a 1-n relation can take the following forms:

- the annotated relation field can be either optional or required
  - if the annotated relation field is required, the relation scalar must be required
  - if the annotated relation field is optional, the relation scalar must be optional
- the other side of the relation must be a list and is always required

So, the following variant of the example above would be _allowed_:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]
}

model Post {
  id        Int    @id @default(autoincrement())
  author    User?  @relation(fields: [authorId], references: [id])
  authorId  Int?
}
```

But this one would be _not allowed_:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  posts     Post[]?  // illegal
}

model Post {
  id        Int    @id @default(autoincrement())
  author    User?  @relation(fields: [authorId], references: [id])
  authorId  Int?

}
```
