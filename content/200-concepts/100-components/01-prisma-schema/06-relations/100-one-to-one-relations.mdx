---
title: One-to-one relations
metaDescription: How to define and work with one-to-one relations in Prisma.
---

<TopBlock>

One-to-one (1-1) relations refer to relations where at most one record can be connected on both sides of the relation.

</TopBlock>

### The side _without_ a relation scalar _must_ be optional

In a one-to-one relation, the side of the relation _without_ a relation scalar (the field representing the foreign key in the database) _must_ be optional:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile? // No relation scalar - must be optional
}
```

This restriction was introduced in 2.12.0.

### Example

In the example below, there's one 1-1-relation between `User` and `Profile`:

```prisma
model User {
  id        Int       @id @default(autoincrement())
  profile   Profile?
}

model Profile {
  id      Int    @id @default(autoincrement())
  user    User   @relation(fields: [userId], references: [id])
  userId  Int    // relation scalar field (used in the `@relation` attribute above)
}
```

In the code above, the `userId` relation scalar is a direct representation of the foreign key in the underlying database.

This 1-1-relation expresses the following:

- "a user can have zero or one profiles" (because the `profile` field is [optional](data-model#type-modifiers) on `User`)
- "a profile must always be connected to one user"

In SQL, this is typically modeled as follows:

```sql
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "userId" INTEGER NOT NULL UNIQUE,
    FOREIGN KEY ("userId") REFERENCES "User"(id)
);
```

Notice the `UNIQUE` constraint on the foreign key `userId`. If this `UNIQUE` constraint was missing, the relation would be considered a 1-n relation.

You can also define this relation using [multi-field IDs](../../../reference/api-reference/prisma-schema-reference#id-1):

```prisma
model User {
  firstName String
  lastName  String
  profile   Profile?

  @@id([firstName, lastName])
}

model Profile {
  id               Int      @id @default(autoincrement())
  user             User     @relation(fields: [userFirstName, userLastName], references: [firstName, lastName])
  userFirstName  String     // relation scalar field (used in the `@relation` attribute above)
  userLastName   String     // relation scalar field (used in the `@relation` attribute above)
}
```

In this case, there are _two_ relation scalar fields on `Profile`. This is what the models map to in SQL:

```sql
CREATE TABLE "User" (
    firstName TEXT,
    lastName TEXT,
    PRIMARY KEY ("firstName","lastName")
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "userFirstName" TEXT NOT NULL,
    "userLastName" TEXT NOT NULL,
    UNIQUE ("userFirstName", "userLastName")
    FOREIGN KEY ("userFirstName", "userLastName") REFERENCES "User"("firstName", "lastName")
);
```

### Determining the side of the foreign key

Consider again the above 1-1-relation between `User` and `Profile`. The relation field on the `Profile` model is annotated with the `@relation` attribute:

```prisma
model User {
  id        Int      @id @default(autoincrement())
  name      String
  profile   Profile?
}

model Profile {
  id      Int    @id @default(autoincrement())
  user    User   @relation(fields: [userId], references: [id])
  userId  Int    // relation scalar field (used in the `@relation` attribute above)
}
```

You can also annotate the other side of the relation with the `@relation` attribute. The following example annotates the relation field on the `User` model:

```prisma
model User {
  id         Int       @id @default(autoincrement())
  profile    Profile?  @relation(fields: [profileId], references: [id])
  profileId  Int?      // relation scalar field (used in the `@relation` attribute above)
}

model Profile {
  id      Int     @id @default(autoincrement())
  user    User?
}
```

In the code above, `profileId` is a direct representation of the foreign key in the underlying database.

However, you can still determine yourself on which side of the relation the foreign key should be stored. To store the foreign key on `User` you need to add the `@relation` attribute to its relation field and add a corresponding relation scalar field:

**One relation field required but using `@relation` to determine the foreign key**

```prisma
model User {
  id         Int      @id @default(autoincrement())
  profile    Profile  @relation(fields: [profileId], references: [id]) // references `id` of `Profile`
  profileId  Int      // relation scalar field (used in the `@relation` attribute above)
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User?
}
```

**Both relation fields optional but using `@relation` to determine the foreign key\***

```prisma
model User {
  id         Int       @id @default(autoincrement())
  profile    Profile?  @relation(fields: [profileId], references: [id]) // references `id` of `Profile`
  profileId  Int?      // relation scalar field (used in the `@relation` attribute above)
}

model Profile {
  id   Int    @id @default(autoincrement())
  user User?
}
```

In both cases, the foreign key is now defined on the `profileId` column of the `User` table.